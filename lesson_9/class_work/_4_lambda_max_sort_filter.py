"""
    Использование lambda выражений в функциях
    min(), max()
    sorted(), .sort()
    filter()
    map()
"""


###############################################################################
# max() min()
# примеры приведены для max. min работает аналогично
###############################################################################

a = [1, 2, 3, -1, -7, 10, -12, 4, 5]

# получить самое большое число из списка a
print(max(a))  # 10

# получить самое большое число по модулю (функция abs()) из списка a
print(max(a, key=abs))  # -12

# в key передаем функцию, которая будет применяться к каждому элементу списка
# abs() - возвращает число по модулю ( abs(-20) == 20 )

# получить число из списка, квадрат которого самый большой
print(max(a, key=lambda x: x ** 2))  # -12

# lambda принимает каждое число списка и возвращает его в квадрате
# и уже среди этих квадратов находится самое максимальное число


b = ["a", "asda", "BWETQWE", "dwe", "ASD"]

print(max(b))  # 'dwe'

# функция max возвращает максимальную строку из списка, сравнивая коды символов

# если нужно получить самую длинную строку в списке b
print(max(b, key=len))  # 'BWETQWE'

max(b, key=lambda s: s.lower().count("a"))

# к каждому элементу списка b применяется функция len()


###############################################################################
# sorted()
# Так же можно применить к методу списков sort()
###############################################################################

c = ["A", "django", "Zappelin", "BROWN", "black", "advanced"]

# нужно отсортировать список, применим функцию sorted()
print(sorted(c))  # ['A', 'BROWN', 'Zappelin', 'advanced', 'black', 'django']

# результат не совсем очевидный, но сортировка идет по кодам символов
# ord('A') == 65 ord('a') == 97

# для того, чтобы сортировка была правильной,
# нужно, чтобы все строки были либо в нижнем либо в верхнем регистре

# применим строчную функцию lower ко всем элементам для правильной сортировки
# ['A', 'advanced', 'black', 'BROWN', 'django', 'Zappelin']
print(sorted(c, key=str.lower))
# print(sorted(c, key=lambda s: s.lower()))

# теперь в обратном порядке
# ['Zappelin', 'django', 'BROWN', 'black', 'advanced', 'A']
print(sorted(c, key=str.lower, reverse=True))

d = [
    {
        "name": "Max",
        "email": "max@gmail.com",
        "bday": "19.10.1999",
        "country": "Ukraine",
    },
    {
        "name": "Ann",
        "email": "ann@gmail.com",
        "bday": "19.10.1999",
        "country": "Ukraine",
    },
    {
        "name": "John",
        "email": "john@gmail.com",
        "bday": "19.10.1999",
        "country": "Ukraine",
    },
]

# необходимо отсортировать список пользователей по имени
print(sorted(d, key=lambda data: data["name"]))  # сортировка по имени
print(sorted(d, key=lambda data: data["email"]))  # сортировка по email

# lambda принимает каждый элемент, т.е. словарь, и возвращает значение ключа
# если имена могуть быть написаны и с большой и с маленькой буквы,
# тогда для более правильно сортировки применим метод lower()
print(sorted(d, key=lambda data: data["name"].lower()))  # сортировка по имени

# если нужно отсортировать по нескольким полям, тогда lambda должна вернуть кортеж
print(sorted(d, key=lambda data: (data["name"], data["email"])))
# сортировка по имени, но если попадутся одинаковые имена,
# то эти записи будут отсортированы по email


# аналогично можно отсортировать список списков по конкретному элементу
my_list = [[1, 2, 3, 4], [5, 1, 3, 5], [1, 3, 2, 4]]

# например, отсортируем список по 2 элементу каждого вложенного списка
print(sorted(my_list, key=lambda data: data[1]))


###############################################################################
# filter(func, iter)
# применяет функцию к каждому элементу последовательности и если функция вернет
# True, то оставляет элемент, если False - отсеивает
###############################################################################

a = [1, 2, 3, -1, -7, 10, -12, 4, 5]

# получить все парные числа из списка a

# вариант с конструктором списка
print([i for i in a if i % 2 == 0])  # [2, 10, -12, 4]

# аналогичный результат с помощью filter и lambda
print(list(filter(lambda x: x % 2 == 0, a)))  # [2, 10, -12, 4]

# получить тех пользователей из списка d, имена которых состоят из 3 букв
print(list(filter(lambda data: len(data["name"]) == 3, d)))


###############################################################################
# map(func, iter)
# map применяет переданную функцию к каждому элементу последовательности
# и возвращает генератор (то есть не создает список и не забивает память)
###############################################################################

digits = [1, 2, 3, -1, -7, 10, -12, 4, 5]

# например, нужно сделать список из модулей элементов списка digits

# вариант с конструктором
print([abs(i) for i in digits])  # [1, 2, 3, 1, 7, 10, 12, 4, 5]

# вариант с map
print(list(map(abs, digits)))  # [1, 2, 3, 1, 7, 10, 12, 4, 5]

# на месте функции может быть любая
# например, применить функцию которая возведет в квадрат положительные числа,
# а отрицательные вернет по модулю
print(list(map(lambda x: x ** 2 if x > 0 else abs(x), digits)))

# аналогичное решение с конструктором
print([i ** 2 if i > 0 else abs(i) for i in digits])

# вычислить сумму чисел, введенных через пробел с клавиатуры
print(sum(map(int, input("Введите числа через пробел: ").split())))

# Введенные числа с помощью split() разбиваются в список
# затем к каждому элементу списка применяется функция int
# после чего все элементы суммируются функцией sum и выводится на экран
